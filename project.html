<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>HG2051 – Group Project</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  { color: #f8f8f2; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #a6e22e; } /* Attribute */
code span.bn { color: #ae81ff; } /* BaseN */
code span.bu { color: #66d9ef; } /* BuiltIn */
code span.cf { color: #f92672; font-weight: bold; } /* ControlFlow */
code span.ch { color: #e6db74; } /* Char */
code span.cn { color: #ae81ff; } /* Constant */
code span.co { color: #88846f; font-style: italic; } /* Comment */
code span.cv { color: #88846f; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #e6db74; font-style: italic; } /* Documentation */
code span.dt { color: #66d9ef; } /* DataType */
code span.dv { color: #ae81ff; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #b08000; } /* Float */
code span.fu { color: #a6e22e; } /* Function */
code span.im { } /* Import */
code span.in { color: #e6db74; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #f92672; font-weight: bold; } /* Keyword */
code span.op { color: #f92672; } /* Operator */
code span.ot { } /* Other */
code span.pp { color: #66d9ef; } /* Preprocessor */
code span.sc { color: #ae81ff; } /* SpecialChar */
code span.ss { color: #ffe792; } /* SpecialString */
code span.st { color: #ffe792; } /* String */
code span.va { color: #f8f8f2; } /* Variable */
code span.vs { color: #e6db74; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/main.css?v=1" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Group Project</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#updates">Updates</a></li>
<li><a href="#task">Task</a></li>
<li><a href="#directions-for-students">Directions for Students</a></li>
<li><a href="#gold-data">Gold Data</a><ul>
<li><a href="#reading-the-gold-data">Reading the Gold Data</a></li>
<li><a href="#looking-up-synsets-from-synset-ids">Looking Up Synsets From Synset-IDs</a></li>
</ul></li>
<li><a href="#producing-annotations">Producing Annotations</a></li>
<li><a href="#evaluation">Evaluation</a></li>
<li><a href="#report">Report</a></li>
<li><a href="#extra-credit">Extra Credit</a><ul>
<li><a href="#multi-word-expression-mwes">Multi-Word Expression (MWEs)</a></li>
<li><a href="#error-analysis">Error Analysis</a></li>
</ul></li>
<li><a href="#appendix-formatting-the-gold-data">Appendix: Formatting the Gold Data</a></li>
</ul>
</nav>
<main>
<h2 id="updates">Updates</h2>
<ol type="1">
<li>I’ve updated the gold data to remove the part of the Semcor corpus that only annotated verbs. Please get the new files <a href="#gold-data">below</a>.</li>
<li>I have now uploaded the plain-text sentences (detokenized) for the train and test sets. Use these as inputs to your system like <code>sents.txt</code>. Download links are <a href="#gold-data">below</a>.</li>
<li>The evaluation script is uploaded. Download link is <a href="#evaluation">below</a></li>
<li>(2020-11-16) I added more information on the <a href="#report">Report</a> format</li>
<li>(2020-11-16) I expanded on <a href="#producing-annotations">producing annotations</a> and file redirection</li>
</ol>
<h2 id="task">Task</h2>
<p>You will improve upon a basic, automatic WordNet sense tagger. You can create a basic tagger using the NLTK as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="im">import</span> nltk</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">def</span> sense_tag(words):</a>
<a class="sourceLine" id="cb1-4" title="4">    pairs <span class="op">=</span> []</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="cf">for</span> word <span class="kw">in</span> words:</a>
<a class="sourceLine" id="cb1-6" title="6">        synsets <span class="op">=</span> wn.synsets(word)</a>
<a class="sourceLine" id="cb1-7" title="7">        <span class="cf">if</span> synsets:</a>
<a class="sourceLine" id="cb1-8" title="8">            pairs.append((word, synsets[<span class="dv">0</span>]))</a>
<a class="sourceLine" id="cb1-9" title="9">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-10" title="10">            pairs.append((word, <span class="va">None</span>))</a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="cf">return</span> pairs</a></code></pre></div>
<p>This only pairs words with the first synset WordNet has for the word, or <code>None</code> if there are no synsets. You and your group will start with this basic, <em>baseline</em> model, and produce different versions with various improvements. You will then estimate the quality of your tagger against human-annotated <em>gold</em> data.</p>
<h2 id="directions-for-students">Directions for Students</h2>
<p>The <code>sense-tag.py</code> script in your project repository is already written and nothing needs to be changed unless you want to specify additional arguments. There are two modules in the <code>hg2051project</code> package:</p>
<pre><code>hg2051project/
├── __init__.py
├── tagger.py   -- contains code for sense tagging
└── utils.py    -- contains code for miscellaneous tasks (e.g., tokenization)</code></pre>
<p>You are to modify the <code>tagger.py</code> with any improvements to the sense tagging. Functions may be added or modified in <code>utils.py</code> to improve the preprocessing or add postprocessing.</p>
<p>You are expected to implement the following improvements:</p>
<ul>
<li>adjust tokenization and text normalization to better capture the individual words</li>
<li>use part-of-speech tagging to narrow the results (note that you will need to map your part-of-speech tagger’s tags to WordNet’s coarse set <code>n</code>, <code>v</code>, <code>a</code>, <code>r</code>)</li>
<li>avoid annotating unlikely senses on common words (like <code>angstrom.n.01</code> for <em>a</em>)</li>
<li>use sense-tag frequencies (from a gold corpus; see below) to choose the most frequent sense</li>
</ul>
<p>There are a few related tasks necessary to complete the assignment:</p>
<ul>
<li>evaluate your implementation against gold data</li>
<li>write a report detailing your improvements and team member contributions</li>
</ul>
<p>I also want to see you use some software-engineering skills to develop the project. For example:</p>
<ul>
<li>track your requirements with <code>requirements.txt</code> or similar</li>
<li>write clean, readable code</li>
<li>write and run unit tests</li>
<li>use GitHub issues and/or project boards to track which member is working on what</li>
</ul>
<p><strong>Note:</strong> for the most-frequent-sense, evaluation, and report tasks, details will be provided at a later time.</p>
<h2 id="gold-data">Gold Data</h2>
<p>The gold data come from the SemCor corpus. You should use the training data for “eyeballing” (as we do below) and for training your system. You may also want to split off some development data to help with tuning your system. You should not evaluate with the gold data until you’re near completion.</p>
<ul>
<li>Training data: <a href="static/semcor-train.txt" class="button">semcor-train.txt</a> (UTF-8, 4.2M) <a href="static/semcor-train-sents.txt" class="button">semcor-train-sents.txt</a> (UTF-8, 1.9M)</li>
<li>Testing data: <a href="static/semcor-test.txt" class="button">semcor-test.txt</a> (UTF-8, 474K) <a href="static/semcor-test-sents.txt" class="button">semcor-test-sents.txt</a> (UTF-8, 218K)</li>
<li>License: <a href="static/semcor-license.txt" class="button">semcor-license.txt</a></li>
</ul>
<p>The corpus has both part-of-speech and WordNet sense annotations. The annotations, however, are on <em>chunks</em> and not words; that is, multi-word expressions get a single tag. For example, let’s look at the first example of the training data:</p>
<pre><code>The
Fulton County Grand Jury        NE
said    state.v.01
Friday  friday.n.01
an
investigation   probe.n.01
of
Atlanta atlanta.n.01
&#39;s
recent  late.s.03
primary election        primary.n.01
produced        produce.v.04
``
no
evidence        evidence.n.01
&#39;&#39;
that
any
irregularities  abnormality.n.04
took place      happen.v.01
.
</code></pre>
<p>You’ll note that some words, like <em>The</em>, <em>of</em>, or <em>’s</em>, do not have any annotation. Named entitles, such as <em>Fulton County Grand Jury</em> only get <code>NE</code> as the tag. <code>NE</code> is not a WordNet sense; SemCor gave a WordNet sense for a generic kind of named entity, such as <code>group.n.01</code>, but I discarded those because named entities are a difficult problem and I think we can just ignore them for this project. Some named entites, however, have a sense, such as <em>Atlanta</em>, because those senses exist in WordNet. Also note that some individual words (like <em>irregularities</em>) have one sense and some multi-word expressions (like <em>took place</em>) have one sense. <del>If you look later in the file, you may also see that some sentences do not have annotation on words that clearly could be given a sense. That is, the annotation is incomplete.</del> (update: I have removed this part of the annotation; it turns out that only verbs were annotated for half the corpus).</p>
<h3 id="reading-the-gold-data">Reading the Gold Data</h3>
<p>I have provided the <code>load()</code> function in the <code>evaluate.py</code> script (see below) which loads the Semcor files, and you are free to use it. If you have already written something that works but want to use my implementation in the end, keep your version around with a comment. I will consider the effort put into your version when assigning partial credit). The <code>load()</code> function works like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="op">&gt;&gt;&gt;</span> sentences <span class="op">=</span> load(<span class="st">&#39;semcor-train.txt&#39;</span>)</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="op">&gt;&gt;&gt;</span> first_sent <span class="op">=</span> sentences[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="cf">for</span> words, label <span class="kw">in</span> first_sent[:<span class="dv">3</span>]:</a>
<a class="sourceLine" id="cb4-4" title="4">...     <span class="bu">print</span>(words, <span class="ss">f&#39;label=</span><span class="sc">{</span>label<span class="sc">!r}</span><span class="ss">&#39;</span>)</a>
<a class="sourceLine" id="cb4-5" title="5">... </a>
<a class="sourceLine" id="cb4-6" title="6">(<span class="st">&#39;The&#39;</span>,) label<span class="op">=</span><span class="va">None</span></a>
<a class="sourceLine" id="cb4-7" title="7">(<span class="st">&#39;Fulton&#39;</span>, <span class="st">&#39;County&#39;</span>, <span class="st">&#39;Grand&#39;</span>, <span class="st">&#39;Jury&#39;</span>) label<span class="op">=</span><span class="st">&#39;NE&#39;</span></a>
<a class="sourceLine" id="cb4-8" title="8">(<span class="st">&#39;said&#39;</span>,) label<span class="op">=</span><span class="st">&#39;state.v.01&#39;</span></a></code></pre></div>
<h3 id="looking-up-synsets-from-synset-ids">Looking Up Synsets From Synset-IDs</h3>
<p>When you read the labels from the gold data, you might get one of the following:</p>
<ul>
<li>A valid synset ID, e.g., <code>friday.n.01</code></li>
<li><code>None</code></li>
<li>A non-synset label, e.g., <code>NE</code></li>
<li>An obsolete or invalid synset ID, e.g., <code>called.s.00</code></li>
</ul>
<p>If you try and call <code>wn.synset(label)</code> with any except the valid ID, you’ll get an error, and each gives a different kind of error. Since we did not cover exception handling in class, I will give you the following code which looks up valid IDs and ignores the others:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1"><span class="cf">try</span>:</a>
<a class="sourceLine" id="cb5-2" title="2">    synset <span class="op">=</span> wn.synset(label)</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="cf">except</span> (<span class="pp">AttributeError</span>, <span class="pp">ValueError</span>, nltk.corpus.reader.wordnet.WordNetError):</a>
<a class="sourceLine" id="cb5-4" title="4">    synset <span class="op">=</span> <span class="va">None</span></a></code></pre></div>
<p>You can put this in your function somewhere (and import <code>nltk</code>) and it can help if you need to get the NLTK’s <code>Synset</code> objects for these labels. Note that it is not necessary to use this code if your implementation does not try to look up synsets by IDs with <code>wn.synset()</code>.</p>
<h2 id="producing-annotations">Producing Annotations</h2>
<p>Once your code is working, you can run <code>sense-tag.py</code> as a script with a sentence file as its argument. For example:</p>
<pre class="console"><code>$ python sense-tag.py semcor-test-sents.txt</code></pre>
<p>If all is good, you should see outputs that are formatted like the <a href="#gold-data">gold data</a> printed to the terminal. If you want to write these to a file, you need to <em>redirect</em> them using the <code>&gt;</code> operator:</p>
<pre class="console"><code>$ python sense-tag.py semcor-test-sents.txt &gt; test.sys</code></pre>
<p>This will create or replace the <code>test.sys</code> file with the output of the <code>sense-tag.py</code> command. Once the file is created, you can proceed to <a href="#evaluation">evaluate</a> it.</p>
<h2 id="evaluation">Evaluation</h2>
<p>An evaluation script is provided here: <a href="static/evaluate.py" class="button">evaluate.py</a></p>
<p>You run it at the terminal with two arguments: the gold data and the corresponding system outputs which were <a href="#producing-annotations">created above</a>. (note: the following uses the output of the baseline system without any modifications):</p>
<pre class="console"><code>$ python evaluate.py semcor-test.txt test.sys
[...]
Totals:
  Gold tokens   :  44007
  System tokens :  38435
  Skipped tokens:  28566
  Gold labels   :  21412
  System labels :  22772
  Matched labels:   3327
Scores:
  Precision: 0.15  (3327 / 22772)
  Recall   : 0.16  (3327 / 21412)
  F-score  : 0.15  (2PR / (P + R))</code></pre>
<p>Gold and system tokens are the number of individual tokens (considering multi-word expressions) in each file. When the tokenization method does not produce the same tokens as in the gold, unaligned tokens will be skipped. This number is shown by “skipped tokens” (the default <code>string.split()</code> is really bad! Even the default NLTK tokenizer is much better). Gold and system labels are how many sense annotations there are for each file. The “matched labels” is the number of labels that (a) were on aligned tokens and (b) the same label. Below, the following scores are calculated using the label counts:</p>
<ul>
<li>precision: proportion of system outputs that are correct</li>
<li>recall: proportion of gold annotations correctly predicted by the system</li>
<li>f-score: harmonic mean of precision and recall</li>
</ul>
<p>For this task, calculating the accuracy (proportion of tokens that are correctly labeled or correctly not labeled) is difficult because the number of tokens is not the same for the gold and system files.</p>
<p>Notes:</p>
<ul>
<li>Your grade is <em>not</em> dependent on high scores (I want to see that you’ve done something reasonable for each task)</li>
<li>You are not expected to get perfect tokenization (using <code>nltk.word_tokenize()</code> gets the skipped tokens down to 995, and that’s fine)</li>
<li>The <code>[...]</code> in the example above is for messages about misaligned sentences or tokens, which I’ve hidden above. You can use these messages for debugging, or just ignore them.</li>
<li>I ‘flatten’ the multi-word-expressions (MWEs) in evaluation and repeat the label assigned to them. This means you can get a higher f-score if you get the MWEs correct, but you can also get partial credit if you correctly annotate an individual word from the MWE.</li>
</ul>
<h2 id="report">Report</h2>
<p>The final task is that you write a report describing your efforts. The report should be ~2 pages (or 6-12 paragraphs) It does not need to be a .pdf or .docx file, and instead you can just create a <code>report.md</code> file (preferred) or even just a <code>## Report</code> section of <code>README.md</code>. If you create a new file, don’t forget to add and commit it to Git.</p>
<p>In your report I would like to see the following:</p>
<ul>
<li>Who did what? I.e., what part of the assignment (which functions, or running the experiment, or writing the report) was each member responsible for?</li>
<li>A description of the problem. That is, what issues with sense tagging do you see in the baseline system?</li>
<li>What did you do to fix these problems? Beyond just a technical description of the code you wrote, I’d like to see discussion of your motivation. That is, <em>why</em> do you think your changes fixed the problem?</li>
<li>What did you try that didn’t work? This could be a feature in your system that didn’t help in the end, or perhaps difficulties you had with using the NLTK, Python, etc.</li>
<li>What would you like to do if you had more time? Short of doing the actual error analysis (which is extra credit), does anything seem like “low-hanging fruit” for further improvement? Or is there a method you’re curious about and would have liked to try?</li>
</ul>
<h2 id="extra-credit">Extra Credit</h2>
<p>There are two options (you can do both) for extra credit. The extra credit contributes towards this project and not your overall course grade (you can get 100% without doing extra credit, but cannot go over 100% with it).</p>
<h3 id="multi-word-expression-mwes">Multi-Word Expression (MWEs)</h3>
<p>Sometimes the best sense doesn’t tag a single word but multiple words. For instance, for “coffee filter” you could either tag it as:</p>
<pre><code>coffee  coffee.n.01
filter  filter.n.01</code></pre>
<p>Or as:</p>
<pre><code>coffee filter   coffee_filter.n.01</code></pre>
<p>In general, the more precise sense is better. For this task, you would need to decide how to group words, how to look them up, collectively, in wordnet, and how to decide if a sense for the multi-word expression is better than those for individual words.</p>
<h3 id="error-analysis">Error Analysis</h3>
<p>After you have finished implementing your improvements and have evaluted the tagger’s performance, do a more thorough examination of the cases that went wrong. Are there obvious categories of error types? What might have caused these errors? What would need to be done to fix them?</p>
<h2 id="appendix-formatting-the-gold-data">Appendix: Formatting the Gold Data</h2>
<p>The gold data comes from the SemCor corpus. If you want to adapt the code, you can reuse this. Just save it to a file and run it and it will write the two files in the current directory. Otherwise there is no need to run or understand this code.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" title="1"><span class="im">import</span> nltk</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="im">from</span> nltk.corpus <span class="im">import</span> wordnet <span class="im">as</span> wn</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="im">from</span> nltk.corpus <span class="im">import</span> semcor</a>
<a class="sourceLine" id="cb11-4" title="4"></a>
<a class="sourceLine" id="cb11-5" title="5">train <span class="op">=</span> []</a>
<a class="sourceLine" id="cb11-6" title="6">test <span class="op">=</span> []</a>
<a class="sourceLine" id="cb11-7" title="7"></a>
<a class="sourceLine" id="cb11-8" title="8"><span class="co"># Semcor has both POS and WordNet sense tags. Specify WN senses with &#39;sem&#39;</span></a>
<a class="sourceLine" id="cb11-9" title="9"><span class="co"># Use enumerate() to keep track of which sentence we&#39;re on</span></a>
<a class="sourceLine" id="cb11-10" title="10"><span class="cf">for</span> i, sent <span class="kw">in</span> <span class="bu">enumerate</span>(semcor.tagged_sents(tag<span class="op">=</span><span class="st">&#39;sem&#39;</span>), <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb11-11" title="11">    sent_data <span class="op">=</span> []  <span class="co"># reset list for each sentence</span></a>
<a class="sourceLine" id="cb11-12" title="12"></a>
<a class="sourceLine" id="cb11-13" title="13">    <span class="co"># tagged_sents() returns a list of chunks</span></a>
<a class="sourceLine" id="cb11-14" title="14">    <span class="cf">for</span> chunk <span class="kw">in</span> sent:</a>
<a class="sourceLine" id="cb11-15" title="15"></a>
<a class="sourceLine" id="cb11-16" title="16">        <span class="co"># semcor tags chunks of text as tree objects;</span></a>
<a class="sourceLine" id="cb11-17" title="17">        <span class="cf">if</span> <span class="bu">isinstance</span>(chunk, nltk.tree.Tree):</a>
<a class="sourceLine" id="cb11-18" title="18">            words <span class="op">=</span> chunk.leaves()  <span class="co"># leaves of the tree are a list of words</span></a>
<a class="sourceLine" id="cb11-19" title="19">            label <span class="op">=</span> chunk.label()   <span class="co"># label could be one of several things</span></a>
<a class="sourceLine" id="cb11-20" title="20"></a>
<a class="sourceLine" id="cb11-21" title="21">            <span class="co"># ignore any synset for named entities</span></a>
<a class="sourceLine" id="cb11-22" title="22">            <span class="cf">if</span> chunk.height() <span class="op">==</span> <span class="dv">3</span> <span class="kw">and</span> chunk[<span class="dv">0</span>].label() <span class="op">==</span> <span class="st">&#39;NE&#39;</span>:</a>
<a class="sourceLine" id="cb11-23" title="23">                label <span class="op">=</span> <span class="st">&#39;NE&#39;</span></a>
<a class="sourceLine" id="cb11-24" title="24">            <span class="co"># some other string labels may be synset identifiers (but maybe not)</span></a>
<a class="sourceLine" id="cb11-25" title="25">            <span class="cf">elif</span> <span class="bu">isinstance</span>(label, <span class="bu">str</span>):</a>
<a class="sourceLine" id="cb11-26" title="26">                <span class="cf">try</span>:</a>
<a class="sourceLine" id="cb11-27" title="27">                    label <span class="op">=</span> wn.synset(label).name()</a>
<a class="sourceLine" id="cb11-28" title="28">                <span class="cf">except</span> (<span class="pp">ValueError</span>, nltk.corpus.reader.wordnet.WordNetError):</a>
<a class="sourceLine" id="cb11-29" title="29">                    <span class="cf">pass</span></a>
<a class="sourceLine" id="cb11-30" title="30">            <span class="co"># most will be Lemma objects; get the synset</span></a>
<a class="sourceLine" id="cb11-31" title="31">            <span class="cf">elif</span> <span class="bu">isinstance</span>(label, nltk.corpus.reader.wordnet.Lemma):</a>
<a class="sourceLine" id="cb11-32" title="32">                label<span class="op">=</span> label.synset().name()</a>
<a class="sourceLine" id="cb11-33" title="33">            <span class="co"># ignore anything else</span></a>
<a class="sourceLine" id="cb11-34" title="34">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb11-35" title="35">                label <span class="op">=</span> <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb11-36" title="36"></a>
<a class="sourceLine" id="cb11-37" title="37">        <span class="co"># untagged text appears as a list of words</span></a>
<a class="sourceLine" id="cb11-38" title="38">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb11-39" title="39">            words <span class="op">=</span> chunk</a>
<a class="sourceLine" id="cb11-40" title="40">            label <span class="op">=</span> <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb11-41" title="41"></a>
<a class="sourceLine" id="cb11-42" title="42">        sent_data.append(<span class="ss">f&#39;</span><span class="sc">{</span><span class="st">&quot; &quot;</span><span class="sc">.</span>join(words)<span class="sc">}</span><span class="ch">\t</span><span class="sc">{</span>label<span class="sc">}</span><span class="ss">&#39;</span>)</a>
<a class="sourceLine" id="cb11-43" title="43"></a>
<a class="sourceLine" id="cb11-44" title="44">    <span class="co"># Done with a sentence; put every tenth one into the testing data</span></a>
<a class="sourceLine" id="cb11-45" title="45">    <span class="cf">if</span> i <span class="op">%</span> <span class="dv">10</span> <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb11-46" title="46">        test.append(sent_data)</a>
<a class="sourceLine" id="cb11-47" title="47">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb11-48" title="48">        train.append(sent_data)</a>
<a class="sourceLine" id="cb11-49" title="49"></a>
<a class="sourceLine" id="cb11-50" title="50"><span class="co"># print to training file</span></a>
<a class="sourceLine" id="cb11-51" title="51"><span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;semcor-train.txt&#39;</span>, <span class="st">&#39;w&#39;</span>, encoding<span class="op">=</span><span class="st">&#39;utf-8&#39;</span>) <span class="im">as</span> <span class="bu">file</span>:</a>
<a class="sourceLine" id="cb11-52" title="52">    <span class="cf">for</span> lines <span class="kw">in</span> train:</a>
<a class="sourceLine" id="cb11-53" title="53">        <span class="cf">for</span> line <span class="kw">in</span> lines:</a>
<a class="sourceLine" id="cb11-54" title="54">            <span class="bu">print</span>(line, <span class="bu">file</span><span class="op">=</span><span class="bu">file</span>)</a>
<a class="sourceLine" id="cb11-55" title="55">        <span class="bu">print</span>(<span class="bu">file</span><span class="op">=</span><span class="bu">file</span>)  <span class="co"># print a blank line after each sentence</span></a>
<a class="sourceLine" id="cb11-56" title="56"></a>
<a class="sourceLine" id="cb11-57" title="57"><span class="co"># print to testing file</span></a>
<a class="sourceLine" id="cb11-58" title="58"><span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;semcor-test.txt&#39;</span>, <span class="st">&#39;w&#39;</span>, encoding<span class="op">=</span><span class="st">&#39;utf-8&#39;</span>) <span class="im">as</span> <span class="bu">file</span>:</a>
<a class="sourceLine" id="cb11-59" title="59">    <span class="cf">for</span> lines <span class="kw">in</span> test:</a>
<a class="sourceLine" id="cb11-60" title="60">        <span class="cf">for</span> line <span class="kw">in</span> lines:</a>
<a class="sourceLine" id="cb11-61" title="61">            <span class="bu">print</span>(line, <span class="bu">file</span><span class="op">=</span><span class="bu">file</span>)</a>
<a class="sourceLine" id="cb11-62" title="62">        <span class="bu">print</span>(<span class="bu">file</span><span class="op">=</span><span class="bu">file</span>)  <span class="co"># print a blank line after each sentence</span></a></code></pre></div>
</main>
</body>
</html>
